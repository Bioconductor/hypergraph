%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
%\VignetteDepends{apComplex}
%\VignetteKeywords{Protein Complex, Graphs, Shared Structure}
%\VignettePackage{hypergraph}
%\VignetteIndexEntry{SharedItems}

\documentclass[11pt]{article}


\usepackage{amsmath,pstricks}
\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}
\usepackage{times}
\usepackage{comment}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}


\bibliographystyle{plainnat}

\title{Scratch Work for Shared Structure in Protein Complexes}
\author{Seth Falcon}
\date{}

\begin{document}
\maketitle

\section{Intro}

Here's how Tony has described the algorithm:


We develop a method for finding and classifying shared structure in
the protein complexes determined by apComplex. The purpose here is
three fold: (1) determining the sub-complexes shared between two or
more super-complexes; (2) using the super-complexes to annotate to the
functionalities of the proteins making up the sub-complexes; (3)
generalizing the methodology so as to determine similar characteristics
for Categories. The recursive algorithm is based on calculating the
intersections of protein complexes. We calculate the intersection, $I$
of two protein complexes, and compare $I$ with all other protein
complexes within the cell; the algorithm records the subset of
complexes $S = \{C: I \subset C\}$ together with the particular
structure $I$. The algorithm repeats this process over all pair of
protein complexes. The recursive nature of the algorithm comes to play
because the sub-complexes are themselves protein complexes. In this
instance, the algorithm repeats by taking the shared sub-structures as
the complexes themselves.


\section{Basic Usage}

The SharedItems package defines a CategoryMatrix class which you can
think of sort of like an exprSet.  It has a matrix slot that holds to
comembership data (incidence matrix) and it has a CategoryData slot
which is analogous to PhenoData.  This is just a glorified vector that
has some custom subsetting.


The first step is to create a CategoryMatrix from the raw comembership
incidence matrix input.  Here's how that looks:

<<setup>>=
library("hypergraph")
library("apComplex")
## This is the proteinToComplex matrix
data(MBMEcTAP)
@ 

<<dataPrep>>=
p2c <- CategoryMatrix(MBMEcTAP)
@ 

Now we can find shared ``structure'' in the CategoryMatrix.  We have a
SharedItemSet class that represents a common structure.  It has a slot
for the shared items and another slot for the category indices that
have the items.  The category indices always refer to the original
data in the CategoryMatrix.

To find shared item sets, we define a minimum item set size of
interest and call fundSharedItemSets.  We pass in an environment that
maps item set ids\footnote{Currently, we create item set keys by
string-ifying in a naive fashion: paste item indices together with
intervening ``-''s.} to SharedItemSet objects that describe the shared
item set.

<<findSharedItemSets>>=
minStructureSize <- 6
resultHash <- new.env(hash=TRUE, parent=NULL)
cm <- p2c
for (i in 1:10) {
    print(paste("working on cm of size:", ncol(cm)))
    print(paste("result hash size:", length(ls(resultHash))))
    result <- findSharedItemSets(cm, minStructureSize, resultHash)
    resultHash <- result$itemSetCache
    cm <- result$categoryMatrix
    if (is.null(cm)) {
        print("quitting")
        break
    }
    print(paste("finished", i))
}

## number of items in each shared item set
sizes <- as.numeric(eapply(resultHash, function(x) length(items(x))))
summary(sizes)

## participating cateogires
catGroupSize <- as.numeric(eapply(resultHash, function(x) length(categories(x))))
summary(catGroupSize)


@ 


Here's what one of the SharedItemSets looks like:

<<sharedItemSetExample>>=
itemKeys <- ls(resultHash)
itemKeys[10]
resultHash[[itemKeys[10]]]

itemKeys[5]
resultHash[[itemKeys[5]]]

resultHash[["567-637-913-1239-1252-1336"]]

@ 

\section{Trying to connect to Yeast annotation}

<<yeast1>>=
library("YEAST")

## this is a map of manufacturer id to gene names
v1 = unlist(as.list(YEASTGENENAME))

## some gene names have aliases, we want the non missing ones
v2 = as.list(YEASTALIAS)
v2NA = sapply(v2, function(x) all(is.na(x)))
v2 = v2[!v2NA]

## create a list ow that maps gene names to manufacturer ids.  Include
## all aliases so that we can look up a gene name (even if it is a
## secondary alias) and get back the manufacturer id
vl = sapply(v2, length)
nms = rep(names(v2), vl)
vals = unlist(v2, use.names=FALSE)
ow = split(nms, vals)

## hmm, not sure why 2 is a magic number here, but these gene names
## (or aliases) map to more than one manufacturer id.
owl = sapply(ow, length)
ow[owl==2]

## gene names from the dataset (I guess proteins are named after their gene?)
dnms = toupper(dimnames(MBMEcTAP)[[1]])

## standardize the gene names
vals = toupper(v1)

## indices of dnms that match gene names we know about from YEAST
xx = match(dnms, vals)

## the man ids for matching gene names
xx2 = names(v1)[xx]

## if man id is missing, use gene name instead?  this is a vector of
## mostly man ids with some gene names mixed in?
newN = ifelse(is.na(xx2), dnms, xx2)

## xy is a vector of indices of dnms that are man ids (not gene names)
xy = match(dnms, names(ow))
xy2 = xy[!is.na(xy)]
## nms is the subset of the gene name ==> man id mapping (list) for
## man ids that appear in the dataset?
nms = ow[xy2]
## keep only first man id
nms2 = sapply(nms, function(x) x[1])

## indices of gene names in dataset that appear in newN???  I'm lost
## at this point.
mt2 = match(names(nms2), newN)
nms3 = nms2[!is.na(mt2)]

@ 

\end{document}
